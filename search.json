[{"title":"为 RT-thread 提交的第一个 PR","path":"/2023/09/22/为 RT-thread 提交的第一个 PR/","content":"为 RT-thread 提交的第一个 PR具体问题 [libcpu&#x2F;riscv&#x2F;virt64] fix (#5979) 修复 qemu-riscv-virt64 smode 下无法启动 by leesum1 · Pull Request #7040 · RT-Thread&#x2F;rt-thread · GitHub 在当前 master 分支中，qemu-riscv-virt64 smode 启动有问题，只有在使用 Sifive 工具链 的情况下才能进入系统，使用其他工具链则会报 Illegal Instruction 异常。 经过排查，最终确定是在 startup_gcc.S 没有为 boot_hartid 分配空间，在后续的指令中，发生了错误的修改。 12345boot_hartid: .int.global boot_hartid.global _start.section &quot;.start&quot;, &quot;ax&quot;_start: 12345/* save hartid */la t0, boot_hartid /* global varible rt_boot_hartid */mv t1, a0 /* get hartid in S-mode frome a0 register */// 由于没有为 boot_hartid 分配空间，修改 boot_hartid 导致了其他指令的改动sw t1, (t0) /* store t1 register low 4 bits in memory address which is stored in t0 */ 对应的汇编语句如下，boot_hartid 与 memset 地址相同 1238020001c: 44828293 addi t0,t0,1096 # 80200460 &lt;memset&gt;80200020: 00050313 mv t1,a0 80200024: 0062a023 sw t1,0(t0) map 文件如下，可以明显看到 boot_hartid 的空间为 0x0，地址信息与 memset 相同。 1234.text 0x0000000080200460 0x0 build/kernel/libcpu/risc-v/virt64/startup_gcc.o 0x0000000080200460 boot_hartid.text 0x0000000080200460 0xdc /opt/riscv/lib/gcc/riscv64-unknown-elf/12.2.0/../../../../riscv64-unknown-elf/lib/libc.a(lib_a-memset.o) 0x0000000080200460 memset 在 80200024: 0062a023 sw t1,0(t0) 中修改了 memset 的第一条指令，导致后续调用 memset 时，指令发生错误。 使用不同工具链的情况下， 与 boot_hartid 地址相同的函数会有变化，在使用Sifive 工具链 时，地址信息如下 1234.text 0x00000000802002ce 0x0 build/kernel/libcpu/risc-v/virt64/startup_gcc.o 0x00000000802002ce boot_hartid.text 0x00000000802002ce 0x28 /home/leesum/Downloads/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14/bin/../lib/gcc/riscv64-unknown-elf/10.2.0/../../../../riscv64-unknown-elf/lib/rv64imac/lp64/libc.a(lib_a-atoi.o) 0x00000000802002ce atoi 12380200018: 00000297 auipc t0,0x08020001c: 2b628293 addi t0,t0,694 # 802002ce &lt;atoi&gt;80200020: 832a mv t1,a0 与 atoi 函数地址相同，而 atoi 不是很常用的函数，所以没有在一开始启动的时候就报错。本次提交能够修复上述 bug。 解决方案原来的 boot_hartid 位于 .start 段，作为全局变量。修改后放在了 .data 段，并分配了 4byte 空间，不会与其他符号冲突 1234.data.global boot_hartid /* global varible rt_boot_hartid in .data section */boot_hartid:\t.word 0xdeadbeef 测试环境❯ qemu-system-riscv64 –helpQEMU emulator version 7.2.0","tags":["RT-thread","Github"],"categories":["开源"]},{"title":"Archlinux 解决 KDE X11 多显示器屏幕撕裂的问题","path":"/2023/09/22/Archlinux 解决 KDE X11 多显示器屏幕撕裂的问题/","content":"Archlinux 解决 KDE X11 多显示器屏幕撕裂的问题起因为了写代码方便，购置了一块便携屏幕作为竖屏，和原先的显示屏幕组合使用，如下图所示。 image.png 但是在 X11 下的 kde 显示时，屏幕会撕裂，并且很严重，十分影响体验。换成 Wayland ，则一切良好，但是由于我需要远程连接寝室的电脑，使用 Nomachine 原创连接时，对 Wayland 的支持不好，找了很多方法也没有解决，最终只能回到 X11。硬件信息如下 image.png 解决过程参照 Intel graphics - ArchWiki 安装 xf86-video-intel 驱动，并且按照教程配置。 image.png 出现了非常多的问题，并且找了很多方法都无法完全解决 开机无法进入登陆界面，一直卡在命令行初始化 进入桌面屏幕抖动 解决方法就是,ctrl alt F2 切换到其他 tty ,删除 xf86-video-intel 驱动和添加的配置文件。 结果不断了解，xf86-video-intel 驱动已经不建议使用，X11 已经自带了 intel 核显驱动 modesetting 。 于是为开始查找 modesetting 的 tearing 信息，最终在 Tearfree in modesetting driver is now available but it does not work : archlinux 发现了蛛丝马迹。 在 /etc/X11/xorg.conf.d 下面添加配置文件如下 /etc/X11/xorg.conf.d/20-intel.conf12345678Section &quot;Device&quot; Identifier &quot;Intel Graphics&quot; Driver &quot;modesetting&quot; Option &quot;TearFree&quot; &quot;true&quot; Option &quot;AsyncFlipSecondaries&quot; &quot;true&quot; Option &quot;VariableRefresh&quot; &quot;true&quot; Option &quot;DoubleShadow&quot; &quot;true&quot;EndSectio 其中最主要的是 Driver 选项和 TearFree 选项。但其实按照文章所说，在当时，TearFree 版本的 Xorg 还没有正式发布。需要手动升级才会有效果，命令如下 1yay -S xorg-server-git 如果不出以外，重启后就不会出现屏幕撕裂的现象了。 总结Wayland 确实比 X11 优秀太多，但由于软件兼容性的问题，目前还是无法完全过渡到Wayland ，只能在 X11 下将就着用。","tags":["Archlinux","踩坑记录"],"categories":["Archlinux"]},{"title":"CVA6 乱序执行原理","path":"/2023/09/22/cva6 乱序执行原理/","content":"CVA6 乱序执行原理流水线简介image.png CVA6 流水线分为前端（Frontend）和后端（Backend），通过 Instruction Queue 来实现前后端分离 前端负责取指令，将取得的指令放入 Instruction Queue 后端从 Instruction Queue 读取指令，进行译码，发射，执行，提交等操作。 CVA6 在后端微架构设计上有以下特点 顺序发射（目前版本只能单发射，双发射版本没有合并到主线） DataCapture 模式（所有操作数准备好后，才能离开发射队列） 乱序执行（乱序了但没有完全乱序） 一个 ALU，一个 CSR，一个 BRU，一个 LSU，一个 Multiply 各个执行单元之间没有依赖，可以独立执行，从而实现指令的乱序执行 实际上就是 ALU、BRU（单周期操作） 和 LSU、Multiply（多周期操作） 之间的乱序执行 各个执行单元的结果写入 ScoreBoard 中对应的项 顺序提交 每次读取 ScoreBoard 中最老的指令进行提交 在提交阶段检查中断和异常（为了实现精确中断） 对于一些指令有特殊处理（ csr 指令，访存指令） CVA6 ScoreBoard 乱序执行机制 从架构图中可以看到，ScoreBoard 贯穿了 issue、execute、commit 三级流水线。ScoreBoard 是 CVA6 实现乱序执行的关键！ image.png|1000 ScoreBoard 在流水线中的作用 决定 Issue stage 中的指令是否可以发射（反压） 操作数没有准备好 执行单元没有准备好 为 Issue stage 提供操作数（bypass） 暂存 Excute stage 各个 Fu 执行后的结果 为 Commit stage 提供已经完成的指令进行提交 ScoreBoard_entry 类型 一条指令在经过 ID 阶段后，会被译码为 ScoreBoard_entry_t 类型，并送往 issue stage image.png Issue queue 代码注释为 issue queue，但其实我认为功能上更加接近 rob（reorderbuffer） image.png Issue queue 介绍 Issue queue 用于存储 scoreboard_entry_t issue 阶段进行 push，commit 阶段进行 pop ex 阶段会对 queue 中具体的 scoreboard_entry_t 中的 result 和 valid 进行修改（writeback） image.png rd_clobber_gpr_o(Destination Register) &#x2F;&#x2F; list of clobbered registers to issue stage &#96;output ariane_pkg::fu_t [2**ariane_pkg::REG_ADDR_SIZE-1:0] rd_clobber_gpr_o, rd_clobber_gpr_o 就是上面图中的 （Destination Register），用来标记 32 个通用寄存器是否被占用，以及被哪一个执行单元（fu），占用。 在 issue 阶段进行置 1，在 commit 阶段进行置 0 image.png 计算型指令执行过程 以最基础的计算指令，说明 CVA6 处理器乱序执行的过。更加复杂的访存操作，中断和异常不再本次文章中。 长周期指令与短周期指令的并行假设有下面指令序列，可以明显看出序列之间没有依赖关系 123mul x4 x2 x3 // 5 cycleadd x1 x2 x3 // 1 cyclesub x2 x2 x3 // 1 cycle 指令序列执行过程中 Issue Queue 和 rd_clober_gpr 的变化。 image.png image.png ALU 指令的 back to back 执行 CVA6 每周期发射一条指令，理想情况下的 IPC 为 1。即在执行连续的 ALU 指令时，流水线不会阻塞。 那么就必须解决，RAW、WAW、WAR 依赖 RAW：通过 ScoreBoard 的 bypass 解决 WAW ：可以通过寄存器重命名解决（CVA6 包含一个简单寄存器重命名） WAR：顺序发射的情况下，没有这种情况 假设有一下指令序列，sub 和 add 存在 RAW 依赖关系 12add x1 x2 x3 // 1 cyclesub x2 x2 x1 // 1 cycle 需要从 x1 需要从 Excute bypass 到 Issue 。 image.png 注意：op_bypass 的来源有两个 来自于 Excute Stage 中执行单元的 WriteBack Ports 来自与 ScoreBoard 中的 IssueFIFO image.png|1200 CVA6 中具体的代码实现： image.png 参考资料 https://cva6.readthedocs.io/en/latest/03_cva6_design/issue_stage.html https://github.com/openhwgroup/cva6","tags":["cva6","微架构设计"],"categories":["cva6"]},{"title":"Hello World","path":"/2023/09/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]