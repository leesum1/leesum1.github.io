[{"title":"使用 xmake 来编译 verilator","path":"/2023/11/03/使用 xmake 编译 verilator/","content":"xmake 介绍 https://github.com/xmake-io/xmakehttps://xmake.io/#/getting_started 类似于 CMAKE 国人开发，操作比较友好，有一些坑，但是作者维护积极。 使用 xmake 进行 verilator 项目的编译 xmake 可以用来进行 verilator 项目的编译和管理，但是官方文档介绍比较少，还是有一些坑在里面的。我在 https://github.com/xmake-io/xmake/pull/3944 中总结了使用过程中一些常见的坑。 一个基本的项目框架可以参考下面来自于 https://github.com/leesum1/chisel-fish/blob/main/sim/xmake.lua 123456789101112131415161718192021222324252627282930313233343536add_rules(&quot;mode.release&quot;, &quot;mode.debug&quot;)if is_mode(&quot;release&quot;) then set_optimize(&quot;faster&quot;)endif is_mode(&quot;debug&quot;) then set_symbols(&quot;debug&quot;) set_optimize(&quot;none&quot;) set_policy(&quot;build.sanitizer.address&quot;, true)endadd_requires(&quot;cli11&quot;,&#123;system = false&#125;)add_requires(&quot;catch2&quot;,&#123;system = false&#125;)add_requires(&quot;assert&quot;,&#123;system = true&#125;)add_requires(&quot;elfio&quot;,&#123;system = false&#125;)add_requires(&quot;libsdl&quot;,&#123;system = false&#125;)-- set_policy(&quot;build.warning&quot;, true)-- set_warnings(&quot;all&quot;, &quot;extra&quot;)dd-- 设置 C++20 标准set_languages(&quot;cxx20&quot;)add_rules(&quot;plugin.compile_commands.autoupdate&quot;, &#123;outputdir = &quot;.&quot;&#125;)target(&quot;Vtop&quot;) add_rules(&quot;verilator.binary&quot;) set_toolchains(&quot;@verilator&quot;) add_files(&quot;src/*.cpp&quot;) add_files(&quot;vsrc/*.sv&quot;) add_values(&quot;verilator.flags&quot;,&quot;--top&quot;,&quot;CoreDutFull&quot;) add_values(&quot;verilator.flags&quot;,&quot;--trace-fst&quot;) add_includedirs(&quot;src/include/&quot;) add_packages(&quot;catch2&quot;,&quot;cli11&quot;,&quot;assert&quot;,&quot;elfio&quot;,&quot;libsdl&quot;) add_links(&quot;rv64emu_cbinding&quot;)","tags":["xmake","verilator"],"categories":["开源","工具使用"]},{"title":"一些开源核心的微架构图","path":"/2023/11/03/CPU微架构图/","content":"BlackParrotimage.png NaxRiscvimage.png SHAKTI family C-Class https://c-class.readthedocs.io/en/latest/intro.htmlhttps://gitlab.com/shaktiproject/cores image.png RSD https://github.com/rsd-devel/rsd image.png","tags":["微架构设计"],"categories":["开源"]},{"title":"E203 ICB 总线地址范围判断","path":"/2023/09/22/e203 icb 总线分析/","content":"E203 ICB 总线地址范围判断时序图 参考《手把手教你设计 RISC-V 处理器》 地址范围判断在我参加一生一芯 时，也需要对总线的地址范围进行判断来确定哪一部分是需要进行 Cache 缓存的。我当时是这样写的 1assign in_area = addr&gt;=low &amp;&amp; addr&lt;high 这样写确实可以满足需求，消耗的逻辑元件也会比较多，至少从明面上来看会有两个比较器 E203 ICB 总线的地址范围判断E203 将几大总线的地址范围全都在 config.v 文件里通过宏定义的方式标出来了。下面我用 PPI 总线来举例。 12345// `E203_CFG_ADDR_SIZE 为 32// * PPI : 0x1000 0000 -- 0x1FFF FFFF`define E203_CFG_PPI_ADDR_BASE `E203_CFG_ADDR_SIZE&#x27;h1000_0000// (32-1:32-4)--&gt;(31:28) 即地址高 4 位 --&gt; (32&#x27;h1000_0000 : 32&#x27;h1fff_ffff) 分配给PPI`define E203_CFG_PPI_BASE_REGION `E203_CFG_ADDR_SIZE-1:`E203_CFG_ADDR_SIZE-4 具体使用方法如下： 123// ppi_region_indic 等于 E203_CFG_PPI_ADDR_BASE// E203_PPI_BASE_REGION 等于 E203_CFG_PPI_BASE_REGION wire buf_icb_cmd_ppi = ppi_icb_enable &amp; (buf_icb_cmd_addr[`E203_PPI_BASE_REGION] == ppi_region_indic[`E203_PPI_BASE_REGION]); 乍一看可能会很茫然，但其实原理很简单，就是通过比较地址的高 4 位来确定是否在范围内，通过高位来限制范围。 这样做无疑减少了逻辑器件的消耗，但是是粗细粒度的控制。这种范围控制方式有点类似于计算机网络中子网掩码的概念（原理上应该是一样的）。 知道原理后，再去看 icb 总线扩展模块 rtl/e203/fab/sirv_icb1to16_bus.v，就不会像开始那样一脸茫然了。我截了一部分来分析原理 image.png 这是一个将一个 icb 总线扩展为 16 个 icb 总线的模块，总裁方式是固定优先级，具体实现方式我也没有深究，在这里仅仅分析一些地址的划分。地址划分主要与两个配置参数有关 BASE_ADDR BASE_REGION_LSB，以 AON 为例： 123// * AON : 0x1000 0000 -- 0x1000 7FFF.O0_BASE_ADDR (32&#x27;h1000_0000), .O0_BASE_REGION_LSB (15), O0_BASE_ADDR 确定起始地址O0_BASE_REGION_LSB 确定地址范围所需要的位数，从低位开始将 0x1000 0000 -- 0x1000 7FFF 转换为 2 进制后如下图所示，就可以按照上面所说，通过比较高位蓝色的部分来确定地址范围了。 image.png","tags":["E203","总线"],"categories":["E203"]},{"title":"为 RT-thread 提交的第一个 PR","path":"/2023/09/22/为 RT-thread 提交的第一个 PR/","content":"为 RT-thread 提交的第一个 PR具体问题 [libcpu&#x2F;riscv&#x2F;virt64] fix (#5979) 修复 qemu-riscv-virt64 smode 下无法启动 by leesum1 · Pull Request #7040 · RT-Thread&#x2F;rt-thread · GitHub 在当前 master 分支中，qemu-riscv-virt64 smode 启动有问题，只有在使用 Sifive 工具链 的情况下才能进入系统，使用其他工具链则会报 Illegal Instruction 异常。 经过排查，最终确定是在 startup_gcc.S 没有为 boot_hartid 分配空间，在后续的指令中，发生了错误的修改。 12345boot_hartid: .int.global boot_hartid.global _start.section &quot;.start&quot;, &quot;ax&quot;_start: 12345/* save hartid */la t0, boot_hartid /* global varible rt_boot_hartid */mv t1, a0 /* get hartid in S-mode frome a0 register */// 由于没有为 boot_hartid 分配空间，修改 boot_hartid 导致了其他指令的改动sw t1, (t0) /* store t1 register low 4 bits in memory address which is stored in t0 */ 对应的汇编语句如下，boot_hartid 与 memset 地址相同 1238020001c: 44828293 addi t0,t0,1096 # 80200460 &lt;memset&gt;80200020: 00050313 mv t1,a0 80200024: 0062a023 sw t1,0(t0) map 文件如下，可以明显看到 boot_hartid 的空间为 0x0，地址信息与 memset 相同。 1234.text 0x0000000080200460 0x0 build/kernel/libcpu/risc-v/virt64/startup_gcc.o 0x0000000080200460 boot_hartid.text 0x0000000080200460 0xdc /opt/riscv/lib/gcc/riscv64-unknown-elf/12.2.0/../../../../riscv64-unknown-elf/lib/libc.a(lib_a-memset.o) 0x0000000080200460 memset 在 80200024: 0062a023 sw t1,0(t0) 中修改了 memset 的第一条指令，导致后续调用 memset 时，指令发生错误。 使用不同工具链的情况下， 与 boot_hartid 地址相同的函数会有变化，在使用Sifive 工具链 时，地址信息如下 1234.text 0x00000000802002ce 0x0 build/kernel/libcpu/risc-v/virt64/startup_gcc.o 0x00000000802002ce boot_hartid.text 0x00000000802002ce 0x28 /home/leesum/Downloads/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14/bin/../lib/gcc/riscv64-unknown-elf/10.2.0/../../../../riscv64-unknown-elf/lib/rv64imac/lp64/libc.a(lib_a-atoi.o) 0x00000000802002ce atoi 12380200018: 00000297 auipc t0,0x08020001c: 2b628293 addi t0,t0,694 # 802002ce &lt;atoi&gt;80200020: 832a mv t1,a0 与 atoi 函数地址相同，而 atoi 不是很常用的函数，所以没有在一开始启动的时候就报错。本次提交能够修复上述 bug。 解决方案原来的 boot_hartid 位于 .start 段，作为全局变量。修改后放在了 .data 段，并分配了 4byte 空间，不会与其他符号冲突 1234.data.global boot_hartid /* global varible rt_boot_hartid in .data section */boot_hartid:\t.word 0xdeadbeef 测试环境❯ qemu-system-riscv64 –helpQEMU emulator version 7.2.0","tags":["RT-thread","Github"],"categories":["开源"]},{"title":"Archlinux 解决 KDE X11 多显示器屏幕撕裂的问题","path":"/2023/09/22/Archlinux 解决 KDE X11 多显示器屏幕撕裂的问题/","content":"Archlinux 解决 KDE X11 多显示器屏幕撕裂的问题起因为了写代码方便，购置了一块便携屏幕作为竖屏，和原先的显示屏幕组合使用，如下图所示。 image.png 但是在 X11 下的 kde 显示时，屏幕会撕裂，并且很严重，十分影响体验。换成 Wayland ，则一切良好，但是由于我需要远程连接寝室的电脑，使用 Nomachine 原创连接时，对 Wayland 的支持不好，找了很多方法也没有解决，最终只能回到 X11。硬件信息如下 image.png 解决过程参照 Intel graphics - ArchWiki 安装 xf86-video-intel 驱动，并且按照教程配置。 image.png 出现了非常多的问题，并且找了很多方法都无法完全解决 开机无法进入登陆界面，一直卡在命令行初始化 进入桌面屏幕抖动 解决方法就是,ctrl alt F2 切换到其他 tty ,删除 xf86-video-intel 驱动和添加的配置文件。 结果不断了解，xf86-video-intel 驱动已经不建议使用，X11 已经自带了 intel 核显驱动 modesetting 。 于是为开始查找 modesetting 的 tearing 信息，最终在 Tearfree in modesetting driver is now available but it does not work : archlinux 发现了蛛丝马迹。 在 /etc/X11/xorg.conf.d 下面添加配置文件如下 /etc/X11/xorg.conf.d/20-intel.conf12345678Section &quot;Device&quot; Identifier &quot;Intel Graphics&quot; Driver &quot;modesetting&quot; Option &quot;TearFree&quot; &quot;true&quot; Option &quot;AsyncFlipSecondaries&quot; &quot;true&quot; Option &quot;VariableRefresh&quot; &quot;true&quot; Option &quot;DoubleShadow&quot; &quot;true&quot;EndSectio 其中最主要的是 Driver 选项和 TearFree 选项。但其实按照文章所说，在当时，TearFree 版本的 Xorg 还没有正式发布。需要手动升级才会有效果，命令如下 1yay -S xorg-server-git 如果不出以外，重启后就不会出现屏幕撕裂的现象了。 总结Wayland 确实比 X11 优秀太多，但由于软件兼容性的问题，目前还是无法完全过渡到Wayland ，只能在 X11 下将就着用。","tags":["Archlinux","踩坑记录"],"categories":["Archlinux"]},{"title":"CVA6 乱序执行原理","path":"/2023/09/22/cva6 乱序执行原理/","content":"CVA6 乱序执行原理流水线简介image.png CVA6 流水线分为前端（Frontend）和后端（Backend），通过 Instruction Queue 来实现前后端分离 前端负责取指令，将取得的指令放入 Instruction Queue 后端从 Instruction Queue 读取指令，进行译码，发射，执行，提交等操作。 CVA6 在后端微架构设计上有以下特点 顺序发射（目前版本只能单发射，双发射版本没有合并到主线） DataCapture 模式（所有操作数准备好后，才能离开发射队列） 乱序执行（乱序了但没有完全乱序） 一个 ALU，一个 CSR，一个 BRU，一个 LSU，一个 Multiply 各个执行单元之间没有依赖，可以独立执行，从而实现指令的乱序执行 实际上就是 ALU、BRU（单周期操作） 和 LSU、Multiply（多周期操作） 之间的乱序执行 各个执行单元的结果写入 ScoreBoard 中对应的项 顺序提交 每次读取 ScoreBoard 中最老的指令进行提交 在提交阶段检查中断和异常（为了实现精确中断） 对于一些指令有特殊处理（ csr 指令，访存指令） CVA6 ScoreBoard 乱序执行机制 从架构图中可以看到，ScoreBoard 贯穿了 issue、execute、commit 三级流水线。ScoreBoard 是 CVA6 实现乱序执行的关键！ image.png|1000 ScoreBoard 在流水线中的作用 决定 Issue stage 中的指令是否可以发射（反压） 操作数没有准备好 执行单元没有准备好 为 Issue stage 提供操作数（bypass） 暂存 Excute stage 各个 Fu 执行后的结果 为 Commit stage 提供已经完成的指令进行提交 ScoreBoard_entry 类型 一条指令在经过 ID 阶段后，会被译码为 ScoreBoard_entry_t 类型，并送往 issue stage image.png Issue queue 代码注释为 issue queue，但其实我认为功能上更加接近 rob（reorderbuffer） image.png Issue queue 介绍 Issue queue 用于存储 scoreboard_entry_t issue 阶段进行 push，commit 阶段进行 pop ex 阶段会对 queue 中具体的 scoreboard_entry_t 中的 result 和 valid 进行修改（writeback） image.png rd_clobber_gpr_o(Destination Register) &#x2F;&#x2F; list of clobbered registers to issue stage &#96;output ariane_pkg::fu_t [2**ariane_pkg::REG_ADDR_SIZE-1:0] rd_clobber_gpr_o, rd_clobber_gpr_o 就是上面图中的 （Destination Register），用来标记 32 个通用寄存器是否被占用，以及被哪一个执行单元（fu），占用。 在 issue 阶段进行置 1，在 commit 阶段进行置 0 image.png 计算型指令执行过程 以最基础的计算指令，说明 CVA6 处理器乱序执行的过。更加复杂的访存操作，中断和异常不再本次文章中。 长周期指令与短周期指令的并行假设有下面指令序列，可以明显看出序列之间没有依赖关系 123mul x4 x2 x3 // 5 cycleadd x1 x2 x3 // 1 cyclesub x2 x2 x3 // 1 cycle 指令序列执行过程中 Issue Queue 和 rd_clober_gpr 的变化。 image.png image.png ALU 指令的 back to back 执行 CVA6 每周期发射一条指令，理想情况下的 IPC 为 1。即在执行连续的 ALU 指令时，流水线不会阻塞。 那么就必须解决，RAW、WAW、WAR 依赖 RAW：通过 ScoreBoard 的 bypass 解决 WAW ：可以通过寄存器重命名解决（CVA6 包含一个简单寄存器重命名） WAR：顺序发射的情况下，没有这种情况 假设有一下指令序列，sub 和 add 存在 RAW 依赖关系 12add x1 x2 x3 // 1 cyclesub x2 x2 x1 // 1 cycle 需要从 x1 需要从 Excute bypass 到 Issue 。 image.png 注意：op_bypass 的来源有两个 来自于 Excute Stage 中执行单元的 WriteBack Ports 来自与 ScoreBoard 中的 IssueFIFO image.png|1200 CVA6 中具体的代码实现： image.png 参考资料 https://cva6.readthedocs.io/en/latest/03_cva6_design/issue_stage.html https://github.com/openhwgroup/cva6","tags":["cva6","微架构设计"],"categories":["cva6"]},{"title":"Hello World","path":"/2023/09/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]